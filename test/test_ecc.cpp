/*
 *   Elliptic Curve Digital Signature Algorithm (ECDSA)
 *
 *
 *   This program verifies the signature given to a <file> in
 *   <file>.ecs generated by program ecsign
 *
 *   The curve is y^2=x^3+Ax+B mod p
 *
 *   The file common.ecs is presumed to exist, and to contain the domain
 *   information {p,A,B,q,x,y}, where A and B are curve parameters, (x,y) are
 *   a point of order q, p is the prime modulus, and q is the order of the
 *   point (x,y). In fact normally q is the prime number of points counted
 *   on the curve.
 *
 *   Requires: big.cpp ecn.cpp
 *
 */

#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include "utils.h"
#include <utility>

#include "miracl/ecn.h"

using namespace std;

#ifndef MR_NOFULLWIDTH
Miracl precision(300, 256);
#else
Miracl precision(50, MAXBASE);
#endif

miracl *mip = &precision;

void strip(char *name) { /* strip off filename extension */
    int i;
    for (i = 0; name[i] != '\0'; i++) {
        if (name[i] != '.') continue;
        name[i] = '\0';
        break;
    }
}

class KGC {
private:
    Big s;
public:
    Big bits, p, a, b, q, x0, y0;
    ECn Ppub;
    ECn G;
    explicit KGC(const char*& filename) {
        ifstream common(filename);
        mip->IOBASE = 10;
        common >> bits;
        mip->IOBASE = 16;
        common >> p >> a >> b >> q >> x0 >> y0;
        ecurve(a, b, p, MR_PROJECTIVE);
        this->G = ECn(x0, y0);
        irand(utils::get_seed());
        this->s = rand(256, 2);
        this->Ppub = s * G; // 不能换位
        
    }
    std::pair<Big, Big> generate_partial_key(const std::string&);


public:
    void print_params() {
        std::cout << "bits: " << bits << std::endl;
        std::cout << "p: " << p << std::endl;
        std::cout << "a: " << a << std::endl;
        std::cout << "b: " << b << std::endl;
        std::cout << "q: " << q << std::endl;
        std::cout << "G: " << G << std::endl;
        std::cout << "s: " << s << std::endl;
        std::cout << "Ppub: " << Ppub << std::endl;
    }

};

/**
 * @brief Hash function，string -> big number
*/
Big Hash(std::string& str) { /* compute hash function */
    Big h;
    sha256 sh;
    shs256_init(&sh);
    char *s = const_cast<char*>(str.c_str());
    shs256_hash(&sh, s);
    h = from_binary(20, s);
    return h;
}

int main() {
    const char* filename = "../secp256.ecs";
    KGC* kgc_ptr = new KGC(filename);
    kgc_ptr->print_params();
    
    // ifstream common("../secp256.ecs"); /* construct file I/O streams */
    // //ifstream public_key("public.ecs");



    // ECn G, Pub;
    // int bits, ep;
    // Big a, b, p, q, x, y, v, u1, u2, r, s, h;
    // char ifname[50], ofname[50];


    // /* get public data */
    // common >> bits;
    // mip->IOBASE = 16;
    // common >> p >> a >> b >> q >> x >> y;
    // ecurve(a, b, p, MR_PROJECTIVE);
    // G = ECn(x, y);
    // /* get public key of signer */
    // //public_key >> ep >> x;
    // Pub = ECn(x, ep);  // decompress
    //                    /* get message */

    // std::cout << "p: " << p << std::endl;
    // std::cout << "a: " << a << std::endl;
    // std::cout << "b: " << b << std::endl;
    // std::cout << "q: " << q << std::endl;
    // // cout << "signed file = ";
    // // cin.sync();
    // // cin.getline(ifname, 13);
    // // strcpy(ofname, ifname);
    // // strip(ofname);
    // // strcat(ofname, ".ecs");
    // // message.open(ifname, ios::binary | ios::in);
    // // if (!message) { /* no message */
    // //     cout << "Unable to open file " << ifname << "\n";
    // //     return 0;
    // // }
    // std::string message = "Hello World";
    // h = Hash(message);

    // std::cout << "h: " << h << std::endl;

    // signature.open(ofname, ios::in);
    // if (!signature) { /* no signature */
    //     cout << "signature file " << ofname << " does not exist\n";
    //     return 0;
    // }
    // signature >> r >> s;
    // if (r >= q || s >= q) {
    //     cout << "Signature is NOT verified\n";
    //     return 0;
    // }
    // s = inverse(s, q);
    // u1 = (h * s) % q;
    // u2 = (r * s) % q;

    // G = mul(u2, Pub, u1, G);
    // G.get(v);
    // v %= q;
    // if (v == r)
    //     cout << "Signature is verified\n";
    // else
    //     cout << "Signature is NOT verified\n";
    return 0;
}
